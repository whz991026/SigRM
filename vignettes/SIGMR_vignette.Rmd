---
title: "<center> SIGMR Vignette </center>"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
abstract: |
  The SIGMR package introduces an innovative statistical approach, employing a similarity-guided multi-resolution analysis for precise m6A modification site detection within DART-seq data. This specialized toolkit, consisting of three pivotal functions, empowers researchers to explore single-cell RNA methylation sites comprehensively. SIGMRtest delves deep into m6A modifications at the individual cell level. SIGMR_similarity_test facilitates control group selection based on test cell similarity, with customizable control cell numbers. Lastly, SIGMR_cluster_test is essential for clustering cells based on gene expression or read counts, seamlessly accommodating both test and control groups. This method relies on control cells with similar gene expression patterns for comparison, systematically evaluating test cell behavior. The SIGMR package enhances the accuracy of methylation site results derived from DART-seq data, offering researchers tools. For inquiries, contact Haozhe.Wang17@student.xjtlu.edu.cn. The accompanying document provides an introduction to using the SIGMR package, including a quick start guide, performance comparisons with the original method, and evaluation of clustering or selecting similar expression cells as control cells. It also outlines using the KS test when site labels are unavailable.\n <center> **Table of content** </center>
vignette: >
  % \VignetteIndexEntry{SIGMR_vignette}
  % \VignetteEngine{knitr::rmarkdown}
  % \VignetteEncoding{UTF-8}
  % \VignetteDepends{pROC} 
  % \VignetteDepends{Seurat} 
---

```{r, include = FALSE}
knitr::opts_chunk$set(fig.width=6, fig.height=4,
  collapse = TRUE,
  comment = "#>"
)
```






# Install the package

At the beginning, we need to install the SIGMR package and some other packages required for this R Markdown file.

## Install our package SIGMR
```{r setup}
# install.packages("devtools")
# library("devtools")
# install_github("whz991026/SIGMR")

library(SIGMR)
```



## Install the library need for this r markdown file

Load the other packages:

* library(pROC)
* library(Seurat)
```{r, include=FALSE}




# install.packages("pROC")
library(pROC)



#    install.packages("Seurat")

library(Seurat)


#    install.packages("ggplot2")

library(ggplot2)
```

# Quick start

It demonstrates how to utilize the main function, SIGMRtest(), from the SIGMR package. The primary input for the SIGMRtest function is a matrix or data frame containing four sets of read counts, where rows represent genes, and columns represent single cells. These four sets of read counts are ordered as follows: methylation read counts in the control group, methylation read counts in the test group, unmethylation read counts in the control group, and unmethylation read counts in the test group. This data can be obtained by calling the simulateData() function.

The output of the SIGMRtest function is a list with a length of 7:

* The first part consists of a data frame representing methylation proportions (with rows for genes and columns for single cells) in the test cells.
* The second part comprises a mean methylation proportion vector (with rows for genes and columns for single cells) in the control cells.
* The third part contains a data frame displaying log2 risk ratios for the test cells.
* The fourth part includes a data frame illustrating log2 odds ratios for the test cells.
* The fifth part encompasses a data frame containing p-values for the test cells.
* The sixth part represents estimated gene abundances.
* The seventh part is a data frame of adjusted p-values for the test cells. 


```{r}
set.seed(1)
# first simulate the data
data <- simulateData(test_num = 10,control_num = 30)
# put into the main function SIGMRtest
res <- SIGMRtest(data[[1]],data[[2]],data[[3]],data[[4]])

# meth proportion data frame (row is gene and column is single cell) in the test cells. 
head(res[[1]])

# mean meth proportion vector (row is gene and column is single cell) in the control cells.
head(res[[2]])

# log2 risk ratio data frame for the test cells. 
head(res[[3]])

# log2 odds ratio data frame for the test cells. 
head(res[[4]])

# p value data frame for the test cells. 
head(res[[5]])

# estimated gene abundance
head(res[[6]])

# adjusted p value data frame for the test cells
head(res[[7]])
```


# Simulation Part

This section involves simulating data and evaluating the performance of the SIGMR model compared to the original method. It also includes testing the performance of the SIGMR_cluster_test() or SIGMR_similarity_test() and SIGMRtest() functions to determine whether selecting control cells based on the similarity of their expression profiles yields superior results.

For the simulation data:

* There are 1000 sites.
* The dataset comprises 300 control cells and 500 test cells.
* The logarithm of $q_{ij}$ follows a uniform distribution.
* The detection level $p_{ij}$ also follows a uniform distribution.
* For 50% of the background sites, the detection levels follow a beta distribution and the mean level is (0, 0.4), while the corresponding test data follow a $U(0.5, 0.8)$ distribution.
* For the remaining sites, their detection levels are similar, following a a beta distribution and the mean level is (0, 0.4). 

By the way, the simulateData() function is responsible for generating the dataset, as before, and provides an output list containing methylation read counts in the control group, methylation read counts in the test group, unmethylation read counts in the control group, and unmethylation read counts in the test group.


## Function for the simulation part
### Function in the ScDART paper written by Tegowski et al. 
The details can be found at https://www.cell.com/molecular-cell/pdf/S1097-2765(21)01143-6.pdf. In the paper, two platforms are discussed: the droplet-based 10x Genomics and the plate-based SMART-seq2 platforms. These platforms employ slightly different methods for detecting m6A modifications. Subsequently, we have developed two functions for these two methods, namely, single_test_10x and single_test_SMART.

The single_test_10x() function takes the following inputs: methylation read counts of the control data, methylation read counts of the test data, unmethylation read counts of the control data, and unmethylation read counts of the test data. This method is tailored for 10x Genomics sample preparation and involves the following criteria:

* The test data should have a minimum coverage of 3 reads.
* The detection level of the test data (t/T) should be greater than or equal to 10%.
* The detection level of the test data should be at least 1.5-fold higher than that of the control data.


Conversely, the single_test_SMART() function, designed for SMART-seq2 sample preparation and sequencing, takes similar inputs: methylation read counts of the control data, methylation read counts of the test data, unmethylation read counts of the control data, and unmethylation read counts of the test data. This method applies the following criteria:

* The test data should have a minimum coverage of 20 reads.
* The detection level of the test data (t/T) should be greater than or equal to 10%.
* The detection level of the test data should be at least 1.5-fold higher than that of the control data.
* The detected read counts should be greater than or equal to 2.



```{r,include=FALSE}



single_test_10x <- function(meth_control,meth_test,unmeth_control,unmeth_test){
  
  # combine as the total reads
  data1 <- meth_control+unmeth_control
  data2 <- meth_test+unmeth_test
  
  # calculate the mean p and the variance of the control data
  
  p_control <- apply((meth_control/data1) , 1, mean_na<- function(x) {mean(x,na.rm=TRUE)})
  var_control <- apply((meth_control/data1) , 1, var_na<- function(x){var(x,na.rm=TRUE)})
  
  # find the site satisfies the three conditions
  if (length(dim(meth_test)[2])==0){
     # first condition
      index_1 <- which(data2>=3)
      
      # second condition
      p_test <- meth_test/data2
      index_2 <- which(p_test>=0.1)
      index_2 <- index_2[index_2 %in% index_1] 
      
      #third condition
      index_3 <- which(p_test>=1.5*p_control)
      index <- index_3 [index_3 %in% index_2]
  }else{
    
    
    list_create <- as.list(1 : dim(meth_test)[2])
    
    list_function <- function (x) {
      # first condition
      index_1 <- which(data2[,x]>=3)
      
      # second condition
      p_test <- meth_test[,x]/data2[,x]
      index_2 <- which(p_test>=0.1)
      index_2 <- index_2[index_2 %in% index_1]
      
      #third condition
      index_3 <- which(p_test>=1.5*p_control)
      index <- index_3[index_3 %in% index_2]
    }
    index <- lapply(list_create,list_function)
    
  }
    
    
      return(index)
  
}
    


# put into the SMART model
single_test_SMART <- function(meth_control,meth_test,unmeth_control,unmeth_test){
  
  # combine as the total reads
  data1 <- meth_control+unmeth_control
  data2 <- meth_test+unmeth_test
  
  # calculate the mean p and the variance of the control data
  
  p_control <- apply((meth_control/data1) , 1, mean_na<- function(x) {mean(x,na.rm=TRUE)})
  var_control <- apply((meth_control/data1) , 1, var_na<- function(x){var(x,na.rm=TRUE)})
  
  # find the site satisfies the three conditions
  if (length(dim(meth_test)[2])==0){
     # first condition
      index_1 <- which(data2>=20)
      
      # second condition
      p_test <- meth_test/data2
      index_2 <- which(p_test>=0.1&p_test<=0.95)
      index_2 <- index_2[index_2 %in% index_1] 
      
      #third condition
      index_3 <- which(p_test>=1.5*p_control)
      index_3 <- index_3 [index_3 %in% index_2]
      
      #fourth condition
      index_4 <- which(meth_test>=2)
      index <- index_4 [index_4 %in% index_3]
  }else{
    
    list_create <- as.list(1 : dim(meth_test)[2])
    
    list_function <- function (x) {
       # first condition
      index_1 <- which(data2[,x]>=20)
      
      # second condition
      p_test <- meth_test[,x]/data2[,x]
      index_2 <- which(p_test>=0.1&p_test<=0.95)
      index_2 <- index_2[index_2 %in% index_1]
      
      
      #third condition
      index_3 <- which(p_test>=1.5*p_control)
      index_3 <- index_3 [index_3 %in% index_2]
      
      #fourth condition
      index_4 <- which(meth_test[,x]>=2)
      index <- index_4 [index_4 %in% index_3]
    }
    index <- lapply(list_create,list_function)
   
    
    
    
  }
  
  
  return(index)
  
}






```



### FDR function

FDR_function(): This function calculates the FDR (false discovery rate).
```{r,include=FALSE}
FDR_function <- function(per_me,n_Sites,res,adjust=TRUE,threshold){
  if(adjust==TRUE){
     res <- p.adjust(res,method = "BH",n=length(res))
  }
 
  len_1 <- length(which((res[((round(n_Sites*per_me)+1):n_Sites)]<=threshold)))
  len <- length(which(res<=threshold))
  res <- len_1/(len)
  return(res)
}
```

### TPR function

TPR_function(): This function calculates the TPR (true positive rate).
```{r,include=FALSE}
TPR_function <- function(per_me,n_Sites,res,adjust=TRUE,threshold){
  if(adjust==TRUE){
     res <- p.adjust(res,method = "BH",n=length(res))
  }
 
  len_1 <- length(which((res[(1:(round(n_Sites*per_me)))]<=threshold)))
  len <- (round(n_Sites*per_me))
  res <- len_1/(len)
  return(res)
}
```


### Ratio plot function

ratio_plot(): This function is used to create ratio plots for risk ratio or odds ratio calculations.
```{r,results=FALSE, include=FALSE,echo=FALSE}

ratio_plot <- function(x,idx1,idx2,threeshold){
  index <- c()
  index <- which(x[[5]][,idx1]<=threeshold)
  
  label <- rep("F",dim(x[[5]])[1])
  label[index] <- "T"
  
  data <- data.frame(x[[idx2]][,idx1],x[[6]],label)
  colnames(data) <- c("ratio","q","label")
  
 
 
  
  if (idx2==3){
    
    plot_test <-  ggplot(data)+geom_point(aes(q,ratio,color=label))+
    scale_color_manual(values=c("black","#FF4500"))+
       geom_hline(aes(yintercept=0),colour="red",linetype="dashed")+ylab("risk ratio")+
      ggtitle("Plot of SIGMR result of risk ratio for simulation")+xlab("expression")+
      theme(plot.title = element_text(hjust = 0.5)) 
  }else if (idx2==4){
   
    
    plot_test <- ggplot(data)+geom_point(aes(q,ratio,color=label))+
    scale_color_manual(values=c("black","#FF4500"))+
       geom_hline(aes(yintercept=0),colour="red",linetype="dashed")+ylab("odds ratio")+
       ggtitle("Plot of SIGMR result of odds ratio for simulation")+xlab("expression")+
      theme(plot.title = element_text(hjust = 0.5)) 
  } else{
     plot_test <- ggplot(data)+geom_point(aes(q,ratio,color=label))+
    scale_color_manual(values=c("black","#FF4500"))+
       geom_hline(aes(yintercept=0),colour="red",linetype="dashed")+ylab("TCR")+
       ggtitle("Plot of SIGMR result of tcr TCR simulation")+xlab("expression")+
      theme(plot.title = element_text(hjust = 0.5)) 
  }



    
  return (plot_test)
}


ratio_plot2 <- function(x,idx1,idx2,threeshold,base=10){
  index <- c()
  index <- which(x[[5]][,idx1]<=threeshold)
  
  label <- rep("F",dim(x[[5]])[1])
  label[index] <- "T"
  
  data <- data.frame(x[[idx2]][,idx1],-log(x[[5]][,idx1],base=base),label)
  colnames(data) <- c("ratio","p_value","label")
  
 
 
  
  if (idx2==3){
    
    plot_test <-  ggplot(data)+geom_point(aes(ratio,p_value,color=label))+
    scale_color_manual(values=c("black","#FF4500"))+ylab("-log p value")+
      ggtitle("Plot of SIGMR result of risk ratio for simulation")+xlab("log 2 risk ratio")+
      theme(plot.title = element_text(hjust = 0.5)) 
  }else if(idx2==4){
   
    
        plot_test <-  ggplot(data)+geom_point(aes(ratio,p_value,color=label))+
    scale_color_manual(values=c("black","#FF4500"))+ylab("-log p value")+
      ggtitle("Plot of SIGMR result of odds ratio for simulation")+xlab("log 2 odds ratio")+
      theme(plot.title = element_text(hjust = 0.5))
  } else{
    plot_test <-  ggplot(data)+geom_point(aes(ratio,p_value,color=label))+
    scale_color_manual(values=c("black","#FF4500"))+ylab("-log p value")+
      ggtitle("Plot of SIGMR result of TCR for simulation")+xlab("TCR")+
      theme(plot.title = element_text(hjust = 0.5))
  }



    
  return (plot_test)
}
```



### test_function()
In the following, test_function() is the function used to simulate data and obtain results from the SIGMR, 10x, and SMART models. Since the 10x and SMART methods can only determine whether sites are m6A or not, whereas the SIGMR provides p-values, we establish a threshold to ensure that the number of m6A sites detected by SIGMR matches that of 10x or SMART for a fair comparison. We then evaluate and compare the performance based on AUC, FDR, and TPR. The output of test_function() is a list with seven components:

* AUC results for each method.
* FDR results for each method.
* TPR results for each method.
* Simulated data.
* Results obtained from SIGMR.
* Results from the 10x method.
* Results from the SMART method."




```{r,include=FALSE}
test_function <- function(n_Sites = 1000, test_num = 200, control_num = 300, 
     min_expression = 0, max_expression = 2, expression_p = 10,per_me =  per_me,
     prange1=c(0,0.4),prange2=c(0.6,1),prange3=c(0,0.4),shape2=10,
      remove.false = TRUE){
#n_Sites = 2000;test_num = 100; control_num = 300; min_expression = 0; max_expression = 3;
#   per_me = 0.5;prange1=c(0,0.2);p_s_1=0.01;prange2=c(0.25,0.4);prange3=c(0,0.3);p_s_3=0.01;
#  remove.false = TRUE
options (warn = - 1)
# simulate data
data <- simulateData(n_Sites = n_Sites,test_num = test_num,control_num = control_num,
          min_expression=min_expression,max_expression=max_expression,
          expression_p =expression_p ,per_me=per_me,
          prange1=prange1,prange2=prange2,prange3=prange3,shape2 = shape2)

# test

res1 = SIGMRtest(data[[1]],data[[2]],data[[3]],data[[4]],method_dispersion = "locfit")
res2 = single_test_10x(data[[1]],data[[2]],data[[3]],data[[4]])
res3 = single_test_SMART(data[[1]],data[[2]],data[[3]],data[[4]])


# set parameter

label=c(rep(0,round(n_Sites*(per_me))),rep(1,round(n_Sites*(1-per_me))))


# calculate auc, fdr, TPR
  

# 10x
list_create <- as.list( 1 : length(res2) )
list_function <- function (x) {
  l1 <- length(res2[[x]])
  
  threshold1 <- res1[[5]][,x][order(res1[[5]][,x])][l1]
  p <-rep(1,n_Sites)
  p[res2[[x]]]<-0
  auc_single_10x <- auc(roc(label,p))
  fdr_single_10x <-FDR_function(per_me,n_Sites,p,threshold=threshold1)
  TPR_single_10x <-TPR_function(per_me,n_Sites,p,threshold=threshold1)
   return(cbind(auc_single_10x,fdr_single_10x,TPR_single_10x))
}
test_results_10x  <- lapply(list_create,list_function)
auc_single_10x <- unlist(lapply(test_results_10x,function(df)df[,1]))
fdr_single_10x <- unlist(lapply(test_results_10x,function(df)df[,2]))
TPR_single_10x <- unlist(lapply(test_results_10x,function(df)df[,3]))

# SMART
list_create <- as.list( 1 : length(res2) )
list_function <- function (x) {
   
  l2 <- length(res3[[x]])
  
  threshold2 <-  res1[[5]][,x][order(res1[[5]][,x])][l2]
  p <-rep(1,n_Sites)
  p[res3[[x]]]<-0
  auc_single_SMART <- auc(roc(label,p))
  fdr_single_SMART <-FDR_function(per_me,n_Sites,p,threshold=threshold2)
  TPR_single_SMART<-TPR_function(per_me,n_Sites,p,threshold=threshold2)
  return(cbind(auc_single_SMART,fdr_single_SMART,TPR_single_SMART))
}
test_results_SMART  <- lapply(list_create,list_function)
auc_single_SMART <- unlist(lapply(test_results_SMART,function(df)df[,1]))
fdr_single_SMART <- unlist(lapply(test_results_SMART,function(df)df[,2]))
TPR_single_SMART <- unlist(lapply(test_results_SMART,function(df)df[,3]))


# SIGMR
list_create <- as.list( 1 : length(res2) )
list_function <- function (x) {
  l1 <- length(res2[[x]])
  l2 <- length(res3[[x]])
  
  threshold1 <- res1[[5]][,x][order(res1[[5]][,x])][l1]
  threshold2 <-  res1[[5]][,x][order(res1[[5]][,x])][l2]
  

  p2 <-rep(1,length(res1[[5]][,x])) 
  p2[which(res1[[5]][,x] <=threshold1) ] <-0 
  auc_SIGMR_10x<- auc(roc(label,p2))
  fdr_SIGMR_10x<-FDR_function(per_me,n_Sites,p2,threshold=threshold1)
  TPR_SIGMR_10x<-TPR_function(per_me,n_Sites,p2,threshold=threshold1)
  
  p2 <-rep(1,length(res1[[5]][,x])) 
  p2[which(res1[[5]][,x] <=threshold2) ] <-0 
  auc_SIGMR_SMART <- auc(roc(label,p2))
  fdr_SIGMR_SMART<-FDR_function(per_me,n_Sites,p2,threshold=threshold2)
  TPR_SIGMR_SMART<-TPR_function(per_me,n_Sites,p2,threshold=threshold2)
  
  return(cbind(auc_SIGMR_10x,fdr_SIGMR_10x,TPR_SIGMR_10x,
               auc_SIGMR_SMART,fdr_SIGMR_SMART,TPR_SIGMR_SMART))
}
test_results_SIGMR  <- lapply(list_create,list_function)
auc_SIGMR_10x <- unlist(lapply(test_results_SIGMR,function(df)df[,1]))
fdr_SIGMR_10x <- unlist(lapply(test_results_SIGMR,function(df)df[,2]))
TPR_SIGMR_10x <- unlist(lapply(test_results_SIGMR,function(df)df[,3]))
auc_SIGMR_SMART <- unlist(lapply(test_results_SIGMR,function(df)df[,4]))
fdr_SIGMR_SMART <- unlist(lapply(test_results_SIGMR,function(df)df[,5]))
TPR_SIGMR_SMART <- unlist(lapply(test_results_SIGMR,function(df)df[,6]))

# set table
auc_table <- cbind(c(auc_SIGMR_10x,auc_SIGMR_SMART,auc_single_10x,auc_single_SMART),
                   c(rep("SIGMR_10x",length(res2)),rep("SIGMR_SMART",length(res2)), rep("single_10x",length(res2)), rep("single_SMART",length(res2))))

fdr_table <- cbind(c(fdr_SIGMR_10x,fdr_SIGMR_SMART,fdr_single_10x,fdr_single_SMART),
                   c(rep("SIGMR_10x",length(res2)),rep("SIGMR_SMART",length(res2)), rep("single_10x",length(res2)), rep("single_SMART",length(res2))))

TPR_table <- cbind(c(TPR_SIGMR_10x,TPR_SIGMR_SMART,TPR_single_10x,TPR_single_SMART),
                   c(rep("SIGMR_10x",length(res2)),rep("SIGMR_SMART",length(res2)), rep("single_10x",length(res2)), rep("single_SMART",length(res2))))

# return list
list_return <- list()
  list_return[[1]]=auc_table
  list_return[[2]]=fdr_table
  list_return[[3]]=TPR_table
  list_return[[4]]=data
  list_return[[5]]=res1
  list_return[[6]]=res2
  list_return[[7]]=res3

return(list_return)

}

```




## Compare origion methods

This section involves comparing the performance of the SIGMR model with the original method by invoking the test_function().
```{r,include=FALSE}
set.seed(1)

n_Sites <- 5000
per_me  <-0.5
test_num = 10
control_num = 300

metric <- test_function(n_Sites = n_Sites, test_num = test_num, control_num =
      control_num , min_expression = 0, max_expression = 3, expression_p=10,
      per_me =  per_me ,prange1=c(0,0.4),prange2=c(0.6,1),
      prange3=c(0,0.4),shape2=10, remove.false = TRUE)

AUC_metric <- metric[[1]]
colnames(AUC_metric) <- c("AUC","method")
AUC_metric <- as.data.frame(AUC_metric)
AUC_metric $AUC <-as.numeric(AUC_metric $AUC)

FDR_metric <- metric[[2]]
colnames(FDR_metric) <- c("FDR","method")
FDR_metric <- as.data.frame(FDR_metric)
FDR_metric $FDR <-as.numeric(FDR_metric $FDR)

TPR_metric <- metric[[3]]
colnames(TPR_metric) <- c("TPR","method")
TPR_metric <- as.data.frame(TPR_metric)
TPR_metric $TPR <-as.numeric(TPR_metric$TPR)


```


### Visualization the results
Visualizing the results of the comparison of performance: AUC, FDR, and TPR.

The single_test_10x() and single_test_SMART() functions can only determine whether a site is m6A or not, resulting in a binary output matrix or data frame. In contrast, the SIGMR output is a p-value matrix or data frame. To ensure fairness, we set the threshold to detect the same number of m6A sites as single_test_10x() or single_test_SMART(), allowing for a direct performance comparison between SIGMR and these methods.

* In the AUC plot, it is evident that the AUC of SIGMR_10x surpasses that of 10x, and the AUC of SIGMR_SMART outperforms SMART.
* Regarding the FDR plot, it's clear that the FDR of SIGMR_10x is lower than that of 10x, and the FDR of SIGMR_SMART is lower than SMART.
* In the TPR plot, we observe that the TPR of SIGMR_10x is superior to that of 10x, and the TPR of SIGMR_SMART excels compared to SMART.
* For the ratio plots, comparing the risk ratio and odds ratio plots on the simulation data with the SIGMR results, it's noticeable that the plots are quite similar when the p-value threshold is set to 0.05. Furthermore, SIGMR does not detect any sites with a log odds ratio or log risk ratio below 0.


```{r,results='hold',echo=FALSE}

give.median1 <- function(x){
  return(c(y = median(x)*1.05, label = round(median(x),3))) 
  # experiment with the multiplier to find the perfect position
} 

give.median2 <- function(x){
  return(c(y = median(x)*1.005, label = round(median(x),3))) 
  # experiment with the multiplier to find the perfect position
} 

ggplot(AUC_metric, aes( y=(AUC),fill=method,x=method)) + 
  geom_boxplot() + ggtitle("Plot of AUC") +
  theme(plot.title = element_text(hjust = 0.5))+
  guides(x = guide_axis(angle = 90))+
  stat_summary(fun.data = give.median2, geom = "text", fun = median)


ggplot(FDR_metric, aes( y=(FDR),fill=method,x=method)) + 
  geom_boxplot() + ggtitle("Plot of FDR")+
  theme(plot.title = element_text(hjust = 0.5)) +
  guides(x = guide_axis(angle = 90))+
  stat_summary(fun.data = give.median1, geom = "text", fun = median)


ggplot(TPR_metric, aes( y=(TPR),fill=method,x=method)) + 
  geom_boxplot() + ggtitle("Plot of TPR")+
  theme(plot.title = element_text(hjust = 0.5)) +
  guides(x = guide_axis(angle = 90))+
  stat_summary(fun.data = give.median2, geom = "text", fun = median)


res = metric[[5]]

ratio_plot(res,1,3,0.05)
ratio_plot(res,1,4,0.05)
ratio_plot(res,1,8,0.05)
ratio_plot2(res,1,3,0.05)
ratio_plot2(res,1,4,0.05)
ratio_plot2(res,1,8,0.05)



```

## Cluster 
We aim to apply a clustering method in which cells with similar gene expression are grouped together. For the test cells, this method not only employs all control cells but also selects control cells with similar gene expression as the control group. We utilize the Seurat clustering method.


### SIGMR_cluster_test function
Before comparing the performance of SIGMR_cluster_test() and SIGMRtest(), let's explore how to use the SIGMR_cluster_test() function. The primary input for the SIGMR_cluster_test function is the same as for the SIGMRtest function: a four read counts matrix or data frame where rows represent genes and columns represent single cells. Additionally, it requires a factor variable named 'cluster variable,' indicating that you must cluster the cells before calling the SIGMR_cluster_test function. For details on other parameters, please refer to the help page.

The outputs of the SIGMR_cluster_test function also consist of a list with a length of 7. The key differences between the outputs of the SIGMR_cluster_test function and the SIGMRtest function are found in elements 2 and 6 of the list:

* The second part contains the mean methylation proportion data frame of the control group.
* The sixth part includes the estimated abundance data frame.


It's important to note that the mean methylation proportion of the control group and the estimated abundance can vary with different clusters, which is why they are represented as data frames rather than vectors.

### cluster by Seurat
```{r, include=FALSE}
set.seed(1)
data <- simulateData(test_num = 10,control_num = 100)

# cluster the cells
data1 <- data[[1]]+data[[3]]
data2 <- data[[2]]+data[[4]]

l <-dim(data1)[2]


data_ <- cbind(data1,data2)
colnames(data_)<- paste0("cell",c(1:dim(data_)[2]))
rownames(data_)<- paste0("gene",c(1:dim(data_)[1]))


##  Seurat
pbmc <- CreateSeuratObject(counts = log2(data_+1), project = "scDART")


all.genes <- rownames(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes)


pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)



pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))


pbmc <- JackStraw(pbmc, num.replicate = 100)
pbmc <- ScoreJackStraw(pbmc, dims = 1:20)



JackStrawPlot(pbmc, dims = 1:20)

ElbowPlot(pbmc)


pbmc <- FindNeighbors(pbmc, dims = 1)
pbmc <- FindClusters(pbmc, resolution = 0.5)

cluster <- Idents(pbmc)




```



### call the SIGMR_cluster_test() function
```{r}
res <- SIGMR_cluster_test(data[[1]],data[[2]],data[[3]],data[[4]],cluster = cluster)

# meth proportion data frame (row is gene and column is single cell) in the test cells. 
head(res[[1]])

# mean meth proportion vector (row is gene and column is single cell) in the control cells.
head(res[[2]])

# log2 risk ratio data frame for the test cells. 
head(res[[3]])

# log2 odds ratio data frame for the test cells. 
head(res[[4]])

# p value data frame for the test cells. 
head(res[[5]])

# estimated gene abundance
head(res[[6]])

# adjusted p value data frame for the test cells
head(res[[7]])
```






## similarity
The cluster method may result in clusters that do not contain any control cells, leaving the test cells without a control group. In such cases, we can employ control cells with the most similar gene expression.

### SIGMR_similarity_test function

Let's take a look at how to use the SIGMR_similarity_test() function. The primary input for the SIGMR_similarity_test() function is the same as that for the SIGMRtest function: a four read counts matrix or data frame where rows represent genes and columns represent single cells. The 'methods' parameter is set to the default "Pearson," but it can also be customized from the vector c("Euclidean distance," "Manhattan distance," "Maximum distance," "Pearson," "Spearman").The 'num_cluster' parameter determines how many similar cells are selected from the control cells to form the control group.

Regarding the outputs, they are identical to those of the SIGMR_cluster_test function.

These revisions should make the text clearer and more grammatically sound.

```{r}

set.seed(1)
data <- simulateData(test_num = 10,control_num = 30)
res = SIGMR_similarity_test(data[[1]],data[[2]],data[[3]],data[[4]],
            method="Pearson",num_control=10)


# meth proportion data frame (row is gene and column is single cell) in the test cells. 
head(res[[1]])

# mean meth proportion vector (row is gene and column is single cell) in the control cells.
head(res[[2]])

# log2 risk ratio data frame for the test cells. 
head(res[[3]])

# log2 odds ratio data frame for the test cells. 
head(res[[4]])

# p value data frame for the test cells. 
head(res[[5]])

# estimated gene abundance
head(res[[6]])

# adjusted p value data frame for the test cells
head(res[[7]])

```



